# README #

Learning to code for node.js, following advice from book [Node.js the Right Way: Practical, Server-Side JavaScript That Scales](https://pragprog.com/book/jwnode/node-js-the-right-way).
### Previous steps ###
Preparation of:

* cygwin environment for testing
* Download and installation of node.js version 0.10.20 (as recommended by the book)
* Preparation of this repository (synchronized using eclipse onboard git)

### Chapter 2: Wrangling the File System ###
First coding for node.js. 

* Use of --harmony (advanced functions not present in stable release 0.10.20)
* Use of constant and let
* Awareness of functions as first-class-citizens
* Use of modules (`fs`, `child_process`) and their methods
* Access to command line interface, including reading arguments and executing commands and getting output from them
* Use of spawn child process
* Use of events generated by `EventEmitter` classes like streams and standard output
* Use of callback functions to respond to events, including exceptions

Discussion on when to use synchronous methods:

* Think Node programs have two phases: (1) initialization phase for mission-critical tasks; (2) operation phase for I/O and interactivity
* Use synchronous methods in phase 1 and don't use them in phase 2. Example is the require function: which evaluates the target module's code and returns the module's object. This is done on the initialization phase.
* If you program can continue without the resource, get the resource asynchronously

### Chapter 3: Networking with Sockets  ###
More asynchronous programming and composition of custom modules :-D <3

* First using raw messages and then using structured protocol such as "Line-Delimited JSON" (LDJ), sending objects with `JSON.stringify(...)`
* First starting with naive server and client (the server ends with error if the client is ended although with telnet/putty client it wasn't a problem): message-boundary; 
* Then being more comprehensive with the different likely network events in client and server sides
* Use of testing program with `setTimeout()` and `clearTimeout()` to simulate the need of buffering data inputs
* Declaration and use of a **custom module** (LDJ buffering client module at `ldj.js`, called `LDJClient`) to buffer incoming data into messages, in this specific case using `EventEmitter`. An example of inheritance in JavaScript (used by node.js) is the following code listing.
```
#!javascript
/**
  * ldj.js Module:
  * ==============
  * DESCRIPTION: Event handler that append raw `data` to the end
  *              of the buffer and so pull completed messages.
  * EXPORT:      LDJClient `constructor()` and `connect()` functions.
  * MODIFY:      Emission of `message` events.
  * USAGE:       ---
  *              const
  *                 ldj=require("./ldj.js"),
  *                 client=ldj.connect(networkStream);
  *              client.on("message",function(message){
  *                // take actions for this message
  *              });
  *              ---
  */
"use strict";
const
    events=require("events"),
    util=require("util"),
    /**
      * DESCRIPTION: Constructor of LDJClient instances, inherites from
      *              EvenEmitter.
      * RECEIVE: stream that emits `data` events, such as a `Socket` connection.
      * RETURN: LDJClient instance.
      * MODIFY: Emission of "message" events.
      */
    LDJClient=function(stream){
        /* call to the EventEmitter on this, equivalent to calling super in
           other languages */
        events.EventEmitter.call(this);
        let
            /* declaration of `self` to regard disambiguation for future use
               of `this` */
            self=this,
            buffer="";
        stream.on("data",function(data){
            /** DESCRIPTION: Event handler that append raw `data` to the end
              *              of the buffer and so pull completed messages
              * RECEIVE:    data: low level source that forms \n-delimited
              *              messages. It supposes the messages are JSON.
              * RETURN: The instance with specific parent's prototype.
              * MODIFY: Emission of event "message" with a high level message.
              */
            buffer+=data;
            let boundary=buffer.indexOf("\n");
            while(boundary!==-1){
                let input=buffer.substr(0,boundary);
                buffer=buffer.substr(boundary+1);
                // the emission of message <3<3<3
                self.emit("message",JSON.parse(input));
                boundary=buffer.indexOf("\n");
            }
        });
    };
    /* associates EventEmitter prototype as LDJClient's prototypal parent;
       which  is a mechanism for JavaScript to look at EventEmitter the
       members it doesn't find looking at LDJClient */
    util.inherits(LDJClient,events.EventEmitter);
    // expose module methods by `exports` <3<3<3<3<3<3!!!
    exports.LDJClient=LDJClient;
    exports.connect=function(stream){
        /** DESCRIPTION:  Enable the creation of intances of LDJClient
          * RECEIVES      stream: the stream to be listen to to create
          *               the LDJClient instance
          * RETURN:       The LDJClient instance!!!
          * MODIFY:       Emission of event "messages" (refer to constructor :-))
          */
        return new LDJClient(stream);
    };
```